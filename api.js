YUI.add("yuidoc-meta", function(Y) {
   Y.YUIDoc = { meta: {
    "classes": [
        "Y.Calendar.JumpNavView",
        "Y.ContextMenuView",
        "Y.DataTable.BaseCellInlineEditor",
        "Y.DataTable.BaseCellPopupEditor",
        "Y.DataTable.CheckboxSelect",
        "Y.DataTable.Editable",
        "Y.DataTable.EditorOptions",
        "Y.DataTable.EditorOptions.autocomplete",
        "Y.DataTable.EditorOptions.calendar",
        "Y.DataTable.EditorOptions.checkbox",
        "Y.DataTable.EditorOptions.date",
        "Y.DataTable.EditorOptions.dropdown",
        "Y.DataTable.EditorOptions.inline",
        "Y.DataTable.EditorOptions.inlineAC",
        "Y.DataTable.EditorOptions.inlineDate",
        "Y.DataTable.EditorOptions.inlineNumber",
        "Y.DataTable.EditorOptions.number",
        "Y.DataTable.EditorOptions.radio",
        "Y.DataTable.EditorOptions.text",
        "Y.DataTable.EditorOptions.textarea",
        "Y.DataTable.Formatters",
        "Y.DataTable.Paginator",
        "Y.DataTable.Selection",
        "Y.FooterView",
        "Y.PaginatorModel",
        "Y.PaginatorView",
        "Y.Plugin.Calendar.JumpNav"
    ],
    "modules": [
        "DataTable",
        "FooterView",
        "Selection",
        "contextmenu",
        "datatable",
        "formatters",
        "gallery-datatable-celleditor-inline",
        "gallery-datatable-celleditor-popup",
        "gallery-datatable-editable",
        "gallery-datatable-paginator",
        "gallery-datatable-selection",
        "gallery-paginator-view"
    ],
    "allModules": [
        {
            "displayName": "contextmenu",
            "name": "contextmenu",
            "description": "This module includes a Y.View class extension that attaches to an existing \"trigger\" Node and uses event delegation to listen\nfor \"contextmenu\" requests (i.e. right-click). When the context menu is invoked, a Y.Overlay object is rendered and displayed\nthat includes user-defined menu items that are related to the context where the menu was invoked.\n\nThis view utilizes several attributes and fires several events that users can listen to in order to take specific actions based\non the \"trigger target\" node.\n\nPlease refer to the [trigger](#attr_trigger) ATTRIBUTE for more description of the target.node and target.trigger.\n\n#####Usage\nTo configure a bare-bones basic contextmenu, you need to provide the `trigger` and `menuItems` attributes as;\n\n    var cmenu = new Y.ContextMenuView({\n       trigger: {\n           node:   Y.one(\".myExistingContainer\"),\n           target:  'li'\n       },\n       menuItems: [ \"Add\", \"Edit\", \"Delete\" ]\n   });\n\nThe `menuItems` can be simple entries or Objects, if they are Objects the \"label\" property will be used to fill the visible Menu (See [menuItems](#attr_menuItems)).\n\n#####Attributes / Events\nAn implementer is typically interested in listening to the following ATTRIBUTE \"change\" events;\n<ul>\n  <li>`selectedMenuChange` : which fires when a contextmenu choice is clicked (see <a href=\"#attr_selectedMenu\">selectedMenu</a>)</li>\n  <li>`contextTargetChange`: which fires when the user \"right-clicks\" on the target.node (see <a href=\"#attr_contextTarget\">contextTarget</a>)</li>\n</ul>\n\nAdditionally please refer to the [Events](#events) section for more information on available events."
        },
        {
            "displayName": "datatable",
            "name": "datatable"
        },
        {
            "displayName": "DataTable",
            "name": "DataTable"
        },
        {
            "displayName": "FooterView",
            "name": "FooterView",
            "description": "FooterView is a YUI View class extension that provides a simple, one row summary row\nto a Datatable. This view provides\nfor a summary row appended to the bottom of the DataTable TBODY, typically consisting\nof **one** TH element (with a colspan) and several TD elements for each desired column\nwhere a \"calculated field\" is desired.\n\nView configuration provides for calculated fields based upon the all of the available\ndataset fields within the DataTable's \"ModelList\".\n\nThe view works with either non-scrolling or scrolling DataTables, and allows for either a\n\"fixed\" view, wherein the footer remains fixed at the bottom of the DataTable contentBox\nwhile the table is scrolled.\n\n#### Calculated Fields\n\nThe current implementation supports the following calculated fields, where they are\nidentified by their placeholder tag for replacement via Y.sub (case insensitive);\n\n* `{sum}` Calculate the arithmetic sum of the specified column in dataset\n* `{min}` Calculate the minimum value of the specified column in dataset\n* `{max}` Calculate the maximum value of the specified column in dataset\n* `{avg}` Calculate the arithmetic average of the of the specified column (synonyms `{mean}`, `{average}`)\n\nAlso, non-looping calcs are;\n\n*  `{row_count}` Returns the number of rows in the dataset\n*  `{col_count}` Returns the number of columns in the dataset (no visibility check)\n*  `{date}` Returns the current date\n*  `{time}` Returns the current time\n\n#### Configuration\n\nYUI 3.6.0 DataTable supports attributes including `footerView` and `footerConfig`.\n\nThis FooterView recognizes the following attributes, which must be configured via the\nDataTable {configs} (see usage example below);\n\n* [`fixed`](#attr_fixed) : Flag indicating if footer should be fixed or floating\n* [`heading`](#attr_heading) : Object, defining the single TH as;\n   * [`colspan`](#attr_heading.colspan) : Number of columns to merge from left for the TH\n   * [`content`](#attr_heading.content) : A string indicating the content of the TH for the footer\n   * [`className`](#attr_heading.className) : Additional classname for TH\n* [`columns`](#attr_columns) : Array of objects, one per desired TD column in footer as;\n   * [`key`](#attr_columns.key) : `key` name from the DataTable columns\n   * [`content`](#attr_columns.content) : String indicating the contents of this TD\n   * [`className`](#attr_columns.className) : Additional classname for TD\n   * [`formatter`](#attr_columns.formatter) : Formatter to apply to this column result\n* [`dateFormat`](#attr_dateFormat) : Format string to use for any {date} fields\n* [`timeFormat`](#attr_timeFormat) : Format string to use for any {time} fields\n\nAdditionally the user can provide a valid function as a column `content` to calculate a\ncustom entry for \n<br/>a column (see [`columns.content`](#attr_columns.content) or [`calcDatasetValue`](#method_calcDatasetValue))\n\n#### Usage\n\n    var dtable = new Y.DataTable({\n        columns:    ['EmpId','FirstName','LastName','NumClients','SalesTTM'],\n        data:       AccountMgr.Sales,\n        scrollable: 'y',\n        height:     '250px',\n        width:      '400px',\n\n        footerView:   Y.FooterView,\n        footerConfig: {\n            fixed:   true,\n            heading: {\n                colspan:\t3,\n                content:\t\"Sales Totals for {row_count} Account Mgrs : &nbsp;\",\n                className:\t\"align-right\"\n            },\n            columns: [\n                { key:'NumClients', content:\"{Avg} avg\", className:\"clientAvg\" },\n                { key:'SalesTTM',   content:\"{sum}\", className:\"salesTotal\", formatter:fmtCurrency }\n            ]\n        }\n    });\n\n    dtable.render('#salesDT');"
        },
        {
            "displayName": "formatters",
            "name": "formatters",
            "description": "Define a \"named\" Column Formatters object and attach it to the Y.DataTable namespace.\nThe named formatters are defined as a series of format strings that are typically used by the\ndata formatting function Y.DataType.Number.format and Y.DataType.Date.format.\n\nThe function [`namedFormatter`](#method_namedFormatter) is defined that can be used to call as a column formatter which\nformats the column cell using the [`formatStrings`](#property_formatStrings) object.\n\nThis module includes an override of the [Y.DataTable.BodyView._createRowHTML](#method_Y.DataTable.BodyView._createRowHTML) method.  Therefore implementers shouldn't call the `namedFormatter` method directly because the overridden method handles the call if the entered formatter string name is recognized.\n \n###Usage\nThe format string names can be used in a column configuration object as follows;\n\n\t\tvar dt1 = new Y.DataTable({\n\t        data: some_data,\n   \t    columns: [\n       \t    { key:\"start_date\", label:\"Start\", formatter:\"fullDate\" },\n           \t{ key:\"end_date\", label:\"End\", formatter:\"default\",\n\t                 formatOptions:{ type:'date', formatConfig:{ format:'%F' } }    },\n   \t        { key:\"qty\", label:\"Inventory Qty\", formatter:\"comma\" },\n       \t    { key:\"cost\", label:\"Carried Cost\", formatter:\"currency\",\n\t                 formatConfig:{ prefix:'Â£', thousandsSeparator:\",\"} }\n   \t    ]\n\t\t}).render();\n\n####Pre-Defined `formatStrings` settings; (specifically, Y.DataTable.Formatters.formatStrings)\nFor \"number\" formatting, using [Y.DataType.Number](http://yuilibrary.com/yui/docs/api/classes/DataType.Number.html#method_format).\n\n<table><tr><th>string</th><th>Formatter Object</th><th>Formatted Example</th></tr>\n<tr><td>`general`</td><td>{ decimalPlaces:0 }</td><td>123457</td></tr>\n<tr><td>`general2`</td><td>{ decimalPlaces:2 }</td><td>123456.79</td></tr>\n<tr><td>`currency`</td><td>{ prefix:'$', decimalPlaces:0, thousandsSeparator:',' }</td><td>$ 123,457</td></tr>\n<tr><td>`currency2`</td><td>{ prefix:'$', decimalPlaces:2, thousandsSeparator:',' }</td><td>$ 123,456.78</td></tr>\n<tr><td>`currency3`</td><td>{ prefix:'$', decimalPlaces:3, thousandsSeparator:',' }</td><td>$ 123,457.789</td></tr>\n<tr><td>`comma`</td><td>{ decimalPlaces:0, thousandsSeparator:','}</td><td>123,457</td></tr>\n<tr><td>`comma2`</td><td>{ decimalPlaces:2, thousandsSeparator:','}</td><td>123,456.78</td></tr>\n<tr><td>`comma3`</td><td>{ decimalPlaces:3, thousandsSeparator:','}</td><td>123,457.789</td></tr>\n</table>\n\nFor \"date\" formatting, using [Y.DataType.Date](http://yuilibrary.com/yui/docs/api/classes/DataType.Date.html#method_format).\n<br/>(Please refer to the Date.format method above for the proper use of \"strftime\" format strings)\n<table><tr><th>string</th><th>Formatter Object</th><th>Formatted Example</th></tr>\n<tr><td>`shortDate`</td><td>{ format:'%D' }</td><td>03/12/92</td></tr>\n<tr><td>`longDate`</td><td>{ format:'%m/%d/%Y' }</td><td>03/12/1992</td></tr>\n<tr><td>`fullDate`</td><td>{ format:'%B %e, %Y' }</td><td>March 12, 1992</td></tr>\n<tr><td>`isoDate`</td><td>{ format:'%F'}</td><td>1992-03-12</td></tr>\n<tr><td>`isoDateTime`</td><td>{ format:'%FT%T'}</td><td>1992-03-12T22:11:07</td></tr>\n</table>\n\n####Replaceable Hash\nThis utility can also replace the cell value with values from a data hash (i.e. JS simple object, consisting of key:value pairs).\nAccess to this capability is by providing a `formatter` as any string not-recognizable in the `formatStrings` object\n**AND** by providing a `formatConfig` object (equal to the hash) in the column definition.\n\n####User-Defined `formatStrings`\nImplementers may add their \"named\" own formatting strings for their own use-cases simply by adding more named formatters to the `formatStrings` object as;\n\n\tY.DataTable.Formatters.formatStrings['myNumberFmtr'] = {\n\t\ttype:'number', \n\t\tformatConfig:{ thousandsSeparator:'x', decimalPlaces:11 } \n\t};\n\tY.DataTable.Formatters.formatStrings['myDateFmtr'] = {\n\t\ttype:'date', \n\t\tformatConfig:{ format:{ \"At the tone the TIME will be %T\" } \n\t};"
        },
        {
            "displayName": "gallery-datatable-celleditor-inline",
            "name": "gallery-datatable-celleditor-inline",
            "description": "A View class that serves as the BASE View class for a TD Cell \"inline\" editor, i.e. an editor that\nis a single INPUT node that completely overlies the TD cell.  This editor is intended to replicate\nthe familiar \"spreadsheet\" type of input.\n\n##### Editing / Validation\n\nThis editor view creates a simple INPUT[type=text] control and repositions and resizes it to match the\nunderlying TD, set with a z-Index to visually appear over the TD cell.\n\nKey listeners are provided to detect changes, prohibit invalid keystrokes (via the [keyFiltering](#attr_keyFiltering)\n setting) and to allow validation upon a \"save\" entry (keyboard RTN stroke) where a [validator](#attr_validator) can\nbe prescribed to allow/disallow changes based upon the overall \"value\" of the INPUT control.\n\n##### Navigation\nThe editor provides the capability to navigate from TD cell via key listeners on the following key\ncombinations;\n * CTRL-arrow keys\n * TAB goes to RIGHT, SHIFT-TAB goes to left\n * ESC cancels editing\n * RTN saves cell\n\nKey navigation can be disabled via the [inputKeys](#attr_inputKeys) attribute set to `false`.\n\nWhen a \"key navigation\" request is received it is passed to the [keyDir](#attr_keyDir) as a change\nin [row,col] that implementers can listen to \"change\" events on, to reposition and open editing on the\nnew relative cell.  (NOTE: This view does not reposition, it simply fires a `keyDirChange` event.\n\n##### Events\nSeveral events are fired by this View;  which can be listened for and acted upon to achieve differing results.\nFor example, the Y.DataTable.EditorOptions.inlineAC (inline autocompletion editor) listens for the\n[editorCreated](#event_editorCreated) event and once received, it configures the autocomplete plugin onto the\nINPUT node.\n\n##### Configuration\nThs Y.DataTable.BaseCellInlineEditor editor is intended to be configured by varying the configuration\nparameters (i.e. attribute and related configuration) to permit a variety of editing features.\n\nSince the View class permits ad-hoc attributes, the implementer can pass many properties in during instantiation\nthat will become available as run-time View attributes.\n\nThis Module includes several pre-defined editor configurations which are stored within the Y.DataTable.EditorOptions\nnamespace (presently there are \"inline\", \"inlineNumber\", \"inlineDate\", \"inlineAC\").  New inline editors can be\ncreated and added to this namespace at runtime, and by defining the `BaseViewClass:Y.DataTable.BaseCellInlineEditor` property.\n\nFor example, the pre-built configuration object for the [inlineDate](Y.DataTable.EditorOptions.inlineDate.html) inline editor\nis stored as `Y.DataTable.EditorOptions.inlineDate`.\n\nTo configure an editor on-the-fly (i.e. within a DataTable column definition) just include the configuration object options\nwithin DT's column `editorConfig` object, which is Y.merge'ed with the pre-built configs;\n\n       // define an 'inlineDate' editor with additional configs ...\n       { key:'date_of_claim', editor:\"inlineDate\", editorConfig:{ dateformat:'%Y-%m-%d'} }\n\nThis `Y.DataTable.BaseCellinlineEditor` class is similar to (and compatible with ) the `Y.DataTable.BaseCellPopupEditor`\nin another gallery module.  Note that since the \"inline\" editor uses a simple INPUT[type=text] Node instead of an\nOverlay the codeline is quite a bit simpler.\n\n###### KNOWN ISSUES:\n  <ul>\n  <li>This View doesn't work well with scrolling DT's, so I've disabled it currently.</li>\n  <li>Sometimes after a DT's `editable` ATTR is toggled true/false a \"cannot read 'style'\" message occurs and editing failes\n       requiring a page refresh.</li>\n  </ul>"
        },
        {
            "displayName": "gallery-datatable-celleditor-popup",
            "name": "gallery-datatable-celleditor-popup",
            "description": "This module defines an extension of View that includes a BASE Y.DataTable.BaseCellPopupEditor View class definition\ncell \"pop-up\" editor.  This view class includes an editor with HTML inserted into an Overlay widget directly over\nthe TD cell.  Positioning, event management, creation/destruction and attribute changes are managed by this class.\n\n##### Configuration\n\nY.DataTable.BaseCellPopupEditor by itself just creates an empty Overlay container, and really isn't meant to be used\nthat way.  The view class includes a number of [attributes](#attrs) that are the key to defining a workable popup editor\nand it's behaviors.\n\nThe Y.DataTable.BaseCellPopupEditor View class communicates with the DataTable via the gallery-datatable-editable\nmodule, which sets up invocation and rendering of this View and establishes listeners for View events, thus the\nDataTable serves as a Controller.\n\nSince the generic View class permits ad-hoc attributes, the implementer can pass many properties in during instantiation\nthat will become available as run-time View attributes.\n\n##### View Construction / Rendering\n\nHTML content that will be set to the Overlay's `bodyContent` is setup via the [templateObject](#attr_templateObject) and\nit's `html` property.  The base view class uses the YUI Template module, and specifically the Template.Micro module to\nbuild out the HTML (Handlebars format is also available).  For many use cases you won't need a fancy \"template\", and\nin fact your templateObject.html may not include any \"template parameters\" at all -- which is perfectly fine.\n\n##### Editing / Validation\n\nThis editor view creates the template'ed content, and attaches the [_inputClass](#property__classInput) wherever the\nimplementer assigns the class tag.  The editor can also be configured to listen to the base view's [editorCreated](#event_editorCreated)\nin order to attach or configure a Widget or another UI component within the View container.\n\nKey listeners are provided to detect changes to the first Node within the container with [_inputClass](#property__classInput)\nset.  These keylisteners can be used prohibit invalid keystrokes (via the [keyFiltering](#attr_keyFiltering) setting) and\nto allow validation upon a \"save\" entry (keyboard RTN stroke) where a [validator](#attr_validator) can be prescribed to\nallow/disallow changes based upon the overall \"value\" of the INPUT control.\n\nIf the implementer has connected a Widget to this View, the widget should be configured by it's own \"selection\" mechanism\nto either call this View's [saveEditor](#event_saveEditor) or[cancelEditor](#event_cancelEditor) methods to ensure proper\nsaving / closing of the Overlay.\n\n##### Navigation\nThe editor provides the capability to navigate from TD cell via key listeners on the following key\ncombinations;\n* CTRL-arrow keys\n* TAB goes to RIGHT, SHIFT-TAB goes to left\n* ESC cancels editing\n* RTN saves cell\n\nKey navigation can be disabled via the [inputKeys](#attr_inputKeys) attribute set to `false`.\n\nWhen a \"key navigation\" request is received it is passed to the [keyDir](#attr_keyDir) as a change\nin [row,col] that implementers can listen to \"change\" events on, to reposition and open editing on the\nnew relative cell.  (NOTE: This view does not reposition, it simply fires a `keyDirChange` event.\n\n##### Events\nSeveral events are fired by this View;  which can be listened for and acted upon to achieve differing results.\nFor example, the Y.DataTable.EditorOptions.inlineAC (inline autocompletion editor) listens for the\n[editorCreated](#event_editorCreated) event and once received, it configures the autocomplete plugin onto the\nINPUT node.\n\n##### Pre-Built Popup Editors\n\nThis Module includes several pre-defined editor configurations which are stored within the Y.DataTable.EditorOptions\nnamespace (presently there are popup editors for \"textbox\", \"textarea\", \"checkbox\", \"radio\", \"dropdown\", \"autocomplete\",\n\"calendar\", \"date\", \"number\").  New popup editors can be created and added to this namespace at runtime,\nand by defining the `BaseViewClass:Y.DataTable.BaseCellPopupEditor` property.\n\nThis Y.DataTable.BaseCellinlineEditor class is similar to (and compatible with ) the Y.DataTable.BaseCellPopupEditor\nin another gallery module.  Note that since the \"inline\" editor uses a simple INPUT[type=text] Node instead of an\nOverlay the codeline is quite a bit simpler.\n\nThe pre-built configuration options are stored in an Object variable Y.DataTable.EditorOptions within\nthe DataTable namespace.  The gallery-datatable-editable module uses the Y.DataTable.EditorOptions to\ncreate required editor View instances.\n\nFor example, the pre-built configuration object for the [number](Y.DataTable.EditorOptions.number.html) popup editor\nis stored as `Y.DataTable.EditorOptions.number`.\n\nTo configure an editor on-the-fly (i.e within a DataTable column definition) just include the configuration object options\nwithin DT's column `editorConfig` object, which is Y.merge'ed with the pre-built configs;\n\n       // Column definition ... disabling keyfiltering and setting a CSS class\n       { key:'firstName',\n         editor:\"text\", editorConfig:{ className:'align-right', keyFiltering:null }\n       }\n\n###### KNOWN ISSUES:\n<ul>\n<li>In-cell key navigation with scrolling DT's can put the View out of the DT limits, no bounds checking is currently done!</li>\n<li>Some problems have been encountered after \"datatable.destroy()\" and then immediate re-building of the same DT without a page refresh.</li>\n</ul>"
        },
        {
            "displayName": "gallery-datatable-editable",
            "name": "gallery-datatable-editable",
            "description": "A DataTable class extension that configures a DT for \"editing\", current deployment supports cell editing\n(and planned near-term support for row editing).\n\nThis module is essentially a base wrapper-class to setup DT for editing with the appropriate attributes and\nlistener creation / detachment.  The real guts of \"datatable-editing\" is in the View class definitions, within\nthe gallery-datatable-celleditor-inline and gallery-datatable-celleditor-inline modules (and possibly future\neditor View class modules).\n\n#### Functionality\n\nThe module is basically intended to keep track of the editing state (via [editable](#attr_editable) attribute) and\nhousekeeping functions with regard to managing editor View instance creation, rendering and destruction.\n\nBy design this module attempts to group common editor View instances wherever possible.  So for a DT with 14 columns\nall set with \"inline\" View classes only 1 View instance is created.\n<br/>Likewise if a DT uses 4 different \"calendar\" editor View types but each one as slightly different \"editorConfig\",\nthen this module creates 4 different calendar View instances to handle the different configurations.\n\nListeners are set for the \"cellEditorSave\" event and saved to the active \"data\" setting within this module.\n\nAdditional capability is provided for cell editing situations to add CSS classes to TD's which are added to \"editable\"\ncolumns (e.g. cursor) to indicate they are \"clickable\".\n\nThis module works sortable, scrollable (y-scrolling currently) to make changes to the client-side of the DT model\n(remote updates should be provided via ModelList sync or user-defined listeners.)\n\n\n#### Attributes\n\nPresently three attributes are provided;\n[editable](#attr_editable), [editOpenType](#attr_editOpenType) and [defaultEditor](#attr_defaultEditor).\n\nThe primary ATTR is the [editable](#attr_editable), which is used to toggle on/off the editing state of the DT\ninstance.\n\nThe [defaultEditor](#attr_defaultEditor) attribute is used to setup a cell editor View instance to be used on all editable columns\nthat don't already have an editor assigned.\n\n##### Column Properties\n\nIn addition to a few new attributes the module also recognizes some new column properties in order to support\ncell-editing in particular;\n<table>\n<tr><th>editable</th><td>{Boolean}</td><td>Flag to indicate if column is editable (set `editable:false` to exclude an\nindividual column)</td></tr>\n<tr><th>editor</th><td>{String}</td><td>Name of the defined Y.DataTable.EditorOptions View configuration for this column.</td></tr>\n<tr><th>editorConfig</th><td>{Object}</td><td>Passed to the View editor class when instantiated, and Y.merge'ed in to become View class\nattributes.</td></tr>\n</table>\n\nWhen this module is loaded and the \"editable:true\" attribute is set, it attempts to economize on the \"instantiation cost\"\nof creating View instances by identifying only editor Views that are required based upon column definitions and/or the\ndefaultEditor attribute. (e.g. if all columns are \"text\" editors, only one \"text\" editor View is instantiated)\n\n##### ... More Info\n\nThe module fires the event [cellEditorSave](#event_cellEditorSave), which can be listened for to provide updating\nof remote data back to a server (assuming a ModelList \"sync\" layer is NOT used).  Haven't provided the equivalent to\nYUI 2.x's \"asyncSubmitter\" because I think this event could easily be listened to in order to provide follow-on\nupdating to remote data stores.\n\nA new class Object (Y.DataTable.EditorOptions) is added to the DataTable namespace that serves as the\ndatastore of the editor View configuration properties.  Each \"key\" (object property) within this object\nis an entrypoint to a specific editor configuration, which are defined in the separate View class extensions (presently\ngallery-datatable-celleditor-inline and gallery-datatable-celleditor-popup. Please see those for specifics.)\n\n###### KNOWN ISSUES:\n  <ul>\n  <li>Works minimally with \"y\" scrolling, \"x\" scrolling still needs work.</li>\n  <li>Initial editor invocation is limited to \"mouse\" actions on TD only (although keyboard navigation cell-to-cell is available).</li>\n  <li>An issue arises on \"datatable.destroy()\" in Chrome from time to time when using inline editors, still investigating why.</li>\n  </ul>\n\n###### FUTURE:\nThis module will be amended to add support for \"row\" editing, if required."
        },
        {
            "displayName": "gallery-datatable-paginator",
            "name": "gallery-datatable-paginator",
            "description": "Defines a Y.DataTable class extension to add capability to support a Paginator View-Model and allow\npaging of actively displayed data within the DT instance.\n\nWorks with either client-side pagination (i.e. local data, usually in form of JS Array) or\nin conjunction with remote server-side pagination, via either DataSource or ModelSync.REST.\n\nAllows for dealing with sorted data, wherein the local data is sorted in place, and in the case of remote data the \"sortBy\"\nattribute is passed to the remote server.\n\n<h4>Usage</h4>\n\n    var dtable = new Y.DataTable({\n        columns:    [ 'firstName','lastName','state','age', 'grade' ],\n        data:       enrollment.records,\n        scrollable: 'y',\n        height:     '450px',\n        sortBy:     [{lastName:'asc'}, {grade:-1}],\n        paginator:  new PaginatorView({\n           model:      new PaginatorModel({itemsPerPage:50, page:3}),\n           container:  '#pagContA'\n        }),\n        resizePaginator: true\n    });\n\n<h4>Client OR Server Pagination</h4>\n\nPagination can either be done solely on the \"client\", or from a remote \"server\".  The attribute [paginationSource](#attr_paginationSource)\nis set to either of these strings.  The trivial case is where the data is coming locally (i.e. in a JS array) and the user requests\n\"client\" pagination.  Likewise when pagination occurs solely on a remote device, \"server\" is very straightforward.  This module also\nprovides a middle-path where the initial payload is obtained from a remote source, and then after loading, pagination is to be done\non the \"client\" (see below).\n\nA determination of whether the source of `data` is either \"local\" data (i.e. a Javascript Array or Y.ModelList), or is\nprovided from a server (either DataSource or ModelSync.REST) is performed within the method [_afterDataReset](#method__afterDataReset).\n\nFor server-side pagination, the OUTGOING request must include (as a minimum);  `page` and `itemsPerPage` querystring\nparameters (all others, including `sortBy` are optional).  Likewise, the INCOMING (returned response) must include as \"meta-data\" at\nleast `totalItems`, plus any other PaginatorModel attributes.   The key item within the returned response is `totalItems'. If the returned\nresponse does not contain `totalItems` metadata <b>the PaginatorView will not be shown!</b>.\n\nWe have provided an attribute [serverPaginationMap](#attr_serverPaginationMap) as an object hash to translate both outgoing\nquerystring parameter names and incoming (response returned) parameter names in order to match what is expected by the\nPaginatorModel.  Please see this attribute or the examples for how to utilize this map for your use case.\n\n<h4>Loading the \"data\" For a Page</h4>\nOnce the \"source of data\" is known, the method [processPageRequest](#method_processPageRequest) fires on a `pageChange`.\n\nFor the case of \"client\" pagination, an internal buffer [_mlistArray](#property__mlistArray) is set to hold all of the data.\nEach page request in this circumstance involves using simply Array slicing methods from the buffer.\n(See method [paginatorLocalRequest](#method_paginatorLocalRequest) for details)\n\nThe case of \"remote data\" (from a server) is actually more straightforward.  For the case of ModelSync.REST remote data the\ncurrent \"pagination state\" is processed through the [serverPaginationMap](#attr_serverPaginationMap) hash (to convert to\nqueryString format) and the ModelList.load() method is called.  For the case of a DataSource, a similar approach is used where\nthe [requestStringTemplate](#attr_requestStringTemplate) is read, processed through the serverPaginationMap hash and a\ndatasource.load() request is fired.\n(See methods [paginatorMLRequest](#method_paginatorMLRequest) and [paginatorDSRequest](#method_paginatorDSRequest)for details)\n\nThis extension DOES NOT \"cache\" pages for remote data, it simply inserts the full returned data into the DT.  So as a consequence,\na pagination state change for remote data involves a simple request sent to the server source (either DataSource or ModelSync.REST)\nand the response results are loaded in the DT as in any other \"response\".\n\n<h4>Loading the \"initial data\" remotely - then using \"client\" Pagination</h4>\n\nA recent revision to this module now allows for the initial payload of data that constitutes the entire \"dataset\" to be loaded\nfrom a remote source (by the standard DataSource or ModelSync.REST methods).\n\nBy setting the [paginationSource](#attr_paginationSource) attribute to \"client\", this module proceeds with paginating the DataTable\nas if the data was initially set within the \"data\" property.\n\n<h4>Sorting</h4>\n\nThis module supports sorting for both client and server side Pagination.  Note that sorting for \"server-side\" is required to be\naccomplished by the remote server; the \"sortBy\" settings are passed in a remote page request.\n\nFor client-side Pagination the task is a more complex.  We utilize an internal buffer to store the client-side data, so therefore\nthe requested \"sorting\" is accomplished internally within method [paginatorSortLocalData](#method_paginatorSortLocalData).\nBasic \"client-side\" sorting is supported in this method (limited to one sort key at a time).\nImplementers may override this method for more complex sorting needs."
        },
        {
            "displayName": "gallery-datatable-selection",
            "name": "gallery-datatable-selection",
            "description": "A class extension for DataTable that adds \"highlight\" and \"select\" actions via mouse selection.\nThe extension works in either \"cell\" mode or \"row\" mode (set via attribute [selectionMode](#attr_selectionMode)).\n\nHighlighting is controlled by the [highlightMode](#attr_highlightMode) attribute (either \"cell\" or \"row\").\n(Highlighting provides a \"mouseover\" indication only), and a delegated \"mouseover\" event is defined in this module.\n\nSelection is provided via \"click\" listeners, by setting a delegated \"click\" handler on the TD or TR elements.\n\nThis extension includes the ability to select \"multiple\" items, by setting the [selectionMulti](#attr_selectionMulti)\nattribute (enabled using browser multi-select click modifier, i.e. \"Cmd\" key on Mac OSX or \"Ctrl\" key on Windows / Linux).\n\nAdditionally, a \"range\" selection capability is provided by using the browser range selector click key modifier,\nspecifically the Shift key on most systems.\n\nThe extension has been written to allow preserving the \"selected\" rows or cells during \"sort\" operations.  This is\naccomplished by storing the selected TR's basis record, specifically the \"clientId\" attribute which remains unique\nafter sorting operations.\n\nSpecific attributes are provided that can be read for current selections, including the ATTRS [selectedRows](#attr_selectedRows),\nand [selectedCells](#attr_selectedCells).\n\nTypical usage would be to set the \"selectionMode\" and \"highlightMode\" attributes (and selectionMulti if desired) and then\nto provide a positive control (like a BUTTON or A link) to process the selections.  Two events are provided,  [selection](#event_selection)\nand [selected](#event_selected) but these fire for every \"click\" action, which may not be ideal -- especially for multi selections."
        },
        {
            "displayName": "gallery-paginator-view",
            "name": "gallery-paginator-view",
            "description": "A Model class extension to be used to track \"pagination state\" of a paged set of control elements.\nFor example, can be used to track the pagination status of a DataTable where the user selects limited\nportions for display, against a larger data set.\n\nThe primary tools for maintaining \"page state\" is through the following attributes;\n\n* `totalItems` &nbsp;&nbsp;  Which represents the \"Total count of items of interest\" (See attribute [totalItems](#attr_totalItems) )\n* `itemsPerPage` &nbsp;&nbsp; Which represents the \"Count of items on each page\" (See attribute [itemsPerPage](#attr_itemsPerPage) )\n*  `page` &nbsp;&nbsp;  The currently selected page, within all pages required that encompass the above two attributes\n    (See attribute [page](#attr_page) )\n\n<h4>Usage</h4>\n\n    // setup a paginator model for 500 'foo' items, paged at 50 per page ...\n    var pagModel = new Y.PaginatorModel({\n       totalItems:     500,\n       itemsPerPage:   50\n    });\n    pagModel.get('totalPages');  // returns 10\n\n    pagModel.set('page',3);\n    pagModel.getAttrs(['lastPage','page','itemIndexStart','itemIndexEnd']);\n    // returns ... { lastPage:1, page:3, itemIndexStart:100, itemIndexEnd:149 }"
        },
        {
            "displayName": "Selection",
            "name": "Selection",
            "description": "A DataTable class extension that adds capability to provide a \"checkbox\" (INPUT[type=checkbox]) selection\ncapability via a new column, which includes \"select all\" checkbox in the TH.  The class uses only a few\ndefined attributes to add the capability.\n\nThis extension works with sorted data and with paginated DataTable (via Y.DataTable.Paginator), by retaining\na set of \"primary keys\" for the selected records.\n\nUsers define the \"primary keys\" by either setting a property flag of \"primaryKey:true\" in the DataTable\ncolumn configuration OR by setting the [primaryKeys](#attr_primaryKeys) attribute.\n\nTo enable the \"checkbox\" selection, set the attribute [checkboxSelectMode](#attr_checkboxSelectMode) to true,\nwhich will add a new column as the first column and sets listeners for checkbox selections.\n\nTo retrieve the \"checkbox\" selected records, the attribute [checkboxSelected](#attr_checkboxSelected) can be\nqueried to return an array of objects of selected records (See method [_getCheckboxSelected](#method__getCheckboxSelected))\nfor details.\n\n####Usage\n\t\tvar dtable = new Y.DataTable({\n\t\t    columns: \t['port','pname', 'ptitle'],\n\t\t    data: \t\tports,\n\t\t    scrollable: 'y',\n\t\t    height: \t'250px',\n\t\t\n\t\t// define two primary keys and enable checkbox selection mode ...\n\t\t    primaryKeys:\t\t[ 'port', 'pname' ],\n\t\t    checkboxSelectMode:\ttrue\n\t\t\n\t\t}).render(\"#dtable\");"
        }
    ]
} };
});